<!DOCTYPE html>
<html>
<body>
  
<h1>JavaScript Arrow Function</h1>

<p>
Arrow functions were introduced in ES6.<br>

Arrow functions allow us to write shorter function syntax:
</p>
<code>
let myFunction = (a, b) => a * b;
</code>
<h3>Output:</h3>
<div>
<p>This example shows the syntax of an Arrow Function, and how to use it.</p>

<p id="demo"></p>

<script>
let myFunction = (a, b) => a * b;
document.getElementById("demo").innerHTML = myFunction(4, 5);
</script>
</div>

<p>Before Arrow:</p>
<code>
hello = function() {
  return "Hello World!";
}
</code>
<h3>Output:</h3>
<div>
<p>This example shows the syntax of a function, without the use of arrow function syntax.</p>

<p id="demo1"></p>

<script>
let hello = "";

hello = function() {
  return "Hello World!";
}

document.getElementById("demo1").innerHTML = hello();
</script>
</div>

<p>With Arrow Function:</p>
<code>
hello = () => {
  return "Hello World!";
}
</code>
<h3>Output:</h3>
<div>
<p>This example shows the syntax of an Arrow Function, and how to use it.</p>

<p id="demo2"></p>

<script>
let hello2 = "";
hello2 = () => {
  return "Hello World!";
}

document.getElementById("demo2").innerHTML = hello2();
</script>
</div>

<p>It gets shorter! If the function has only one statement, and the statement returns a value, you can remove the brackets and the return keyword:</p>

<p><b> Arrow Functions Return Value by Default </b> :</p>

<code>hello = () => "Hello World!";</code>

<p><b>Note:</b> This works only if the function has only one statement.
</p>
<h3>Output:</h3>
<div>
<p>This example shows an Arrow Function without the brackets or the return keyword.</p>

<p id="demo3"></p>

<script>
let hello3 = "";
hello3 = () => "Hello World!";

document.getElementById("demo3").innerHTML = hello3();
</script>
</div>

<p>
If you have parameters, you pass them inside the parentheses:
</p>

<p><b>Arrow Function With Parameters:</b>
 </p>

<code>
hello = (val) => "Hello " + val;
</code>
<h3>Output:</h3>
<div>
<p>This example shows an Arrow Function with a parameter.</p>
<p id="demo4"></p>
<script>
let hello4 = "";

hello4 = (val) => "Hello " + val;
document.getElementById("demo4").innerHTML = hello4("Universe!");
</script>
</div>

<p>
In fact, if you have only one parameter, you can skip the parentheses as well:
</p>

<p>
  <b>
Arrow Function Without Parentheses:
  </b>
</p>
<code>
hello = val => "Hello " + val;
</code>

<h3>Output:</h3>
<div>
<p>This example shows that if you have only one parameter in an Arrow Function, you can skip the parentheses.</p>
<p id="demo5"></p>
<script>
let hello5 = "";

hello5 = val => "Hello " + val;

document.getElementById("demo5").innerHTML = hello5("Universe!");
</script>
</div>

<h2>What About this?</h2>
<p>
The handling of this is also different in arrow functions compared to regular functions.<br><br>

In short, with arrow functions there are no binding of this.<br><br>

In regular functions the this keyword represented the object that called the function, which could be the window, the document, a button or whatever.<br><br>

With arrow functions the this keyword always represents the object that defined the arrow function.<br><br>

Let us take a look at two examples to understand the difference.<br><br>

Both examples call a method twice, first when the page loads, and once again when the user clicks a button.<br><br>

The first example uses a regular function, and the second example uses an arrow function.<br><br>

The result shows that the first example returns two different objects (window and button), and the second example returns the window object twice, because the window object is the "owner" of the function.
</p>

<h3>Example 1</h3>
<p>
With a regular function this represents the object that calls the function:
</p>
<pre>
// Regular Function:
hello = function() {
  document.getElementById("demo").innerHTML += this;
}

// The window object calls the function:
window.addEventListener("load", hello);

// A button object calls the function:
document.getElementById("btn").addEventListener("click", hello);
</pre>
<h3>Output:</h3>
<div>
<p>This example demonstrate that in a regular function, the "this" keyword represents different objects depending on how the function was called.</p>

<p>Click the button to execute the "hello" function again, and you will see that this time "this" represents the button object.</p>

<button id="btn">Click Me!</button>

<p id="demo6"></p>
<script>
let hello6 = "";

hello6 = function() {
  document.getElementById("demo6").innerHTML += this;
}
//The window object calls the function:
window.addEventListener("load", hello6);
//A button object calls the function:
document.getElementById("btn").addEventListener("click", hello6);
</script>
</div>

<h3>Example 2</h3>
<p>With an arrow function this represents the owner of the function:</p>
<pre>
// Arrow Function:
hello = () => {
  document.getElementById("demo").innerHTML += this;
}

// The window object calls the function:
window.addEventListener("load", hello);

// A button object calls the function:
document.getElementById("btn").addEventListener("click", hello);
</pre>
<h3>Output:</h3>
<div>
<p>This example demonstrate that in Arrow Functions, the "this" keyword represents the object that owns the function, no matter who calls the function.</p>

<p>Click the button to execute the "hello" function again, and you will see that "this" still  represents the window object.</p>

<button id="btn7">Click Me!</button>
<p id="demo7"></p>

<script>
let hello7 = "";

hello7 = () => {
document.getElementById("demo7").innerHTML += this;
}

//The window object calls the function:
window.addEventListener("load", hello7);

//A button object calls the function:
document.getElementById("btn7").addEventListener("click", hello7);
</script>
</div>

<p>
Remember these differences when you are working with functions. Sometimes the behavior of regular functions is what you want, if not, use arrow functions.
</p>




</body>
</html>