<!DOCTYPE html>
<html>
<body>

<h1>JavaScript Best Practices</h1>

<p>
Avoid global variables, avoid <span style="color:red;">new</span>, avoid  <span style="color:red;">==</span>, avoid <span style="color:red;">eval()</span>
</p>

<h2>Avoid Global Variables</h2>

<p>Minimize the use of global variables.<br><br>

This includes all data types, objects, and functions.<br><br>

Global variables and functions can be overwritten by other scripts.<br><br>

Use local variables instead, and learn how to use <a href="https://www.w3schools.com/js/js_function_closures.asp">closures</a>.</p>

<h2>Always Declare Local Variables</h2>

<p>All variables used in a function should be declared as local variables.<br><br>

Local variables must be declared with the var, the let, or the const keyword, otherwise they will become global variables.</p>

<p style="background-color:yellow">Strict mode does not allow undeclared variables.</p>

<h2>Declarations on Top</h2>
<p>It is a good coding practice to put all declarations at the top of each script or function.<br><br>

This will:
<ul>
  <li>Give cleaner code</li>
  <li>Provide a single place to look for local variables</li>
  <li>Make it easier to avoid unwanted (implied) global variables</li>
  <li>Reduce the possibility of unwanted re-declarations</li>
</ul>
</p>

<pre>
// Declare at the beginning
let firstName, lastName, price, discount, fullPrice;

// Use later
firstName = "John";
lastName = "Doe";

price = 19.90;
discount = 0.10;

fullPrice = price - discount;
</pre>

<p>This also goes for loop variables:</p>
<cod3>for (let i = 0; i < 5; i++) {</cod3>

<h2>Initialize Variables</h2>
<p>It is a good coding practice to initialize variables when you declare them.<br><br>

This will:
<ul>
  <li>Give cleaner code</li>
  <li>Provide a single place to initialize variables</li>
  <li>Avoid undefined values</li>
</ul></p>

<pre>
// Declare and initiate at the beginning
let firstName = "";
let lastName = "";
let price = 0;
let discount = 0;
let fullPrice = 0,
const myArray = [];
const myObject = {};
</pre>

<p style="background-color:yellow;">Initializing variables provides an idea of the intended use (and intended data type).</p>

<h2>Declare Objects with const</h2>
<p>Declaring objects with const will prevent any accidental change of type:</p>

<h3>Exampke</h3>
<pre>
let car = {type:"Fiat", model:"500", color:"white"};
car = "Fiat";      
// Changes object to string
</pre>
-----------------------------
<pre>
const car = {type:"Fiat", model:"500", color:"white"};
car = "Fiat";     
// Not possible
</pre>

<h2>Declare Arrays with const</h2>
<p>Declaring arrays with const will prevent any accidential change of type:</p>

<h3>Exampke</h3>
<pre>
let cars = ["Saab", "Volvo", "BMW"];
cars = 3;   
// Changes array to number
</pre>

---------------------------------

<pre>
const cars = ["Saab", "Volvo", "BMW"];
cars = 3;   
// Not possible
</pre>

<h2>Don't Use new Object()</h2>
<p>
  <ul>
    <li>Use "" instead of new String()</li>
    <li>Use 0 instead of new Number()</li>
    <li>Use false instead of new Boolean()</li>
    <li>Use {} instead of new Object()</li>
    <li>Use [] instead of new Array()</li>
    <li>Use /()/ instead of new RegExp()</li>
    <li>Use function (){} instead of new Function()</li>
  </ul>
</p>

<h3>Exampke</h3>
<pre>
let x1 = "";            
// new primitive string
let x2 = 0;             
// new primitive number
let x3 = false;        
// new primitive boolean
const x4 = {};         
// new object
const x5 = [];          
// new array object
const x6 = /()/;        
// new regexp object
const x7 = function(){};
// new function object
</pre>
<h3>Output:</h3>
<div>
<p id="demo"></p>
<script>
let x1 = "";
let x2 = 0;
let x3 = false;
const x4 = {};
const x5 = [];
const x6 = /()/;
const x7 = function(){};
document.getElementById("demo").innerHTML =
"x1: " + typeof x1 + "<br>" +
"x2: " + typeof x2 + "<br>" +
"x3: " + typeof x3 + "<br>" +
"x4: " + typeof x4 + "<br>" +
"x5: " + typeof x5 + "<br>" +
"x6: " + typeof x6 + "<br>" +
"x7: " + typeof x7 + "<br>";
</script>
</div>

<h2>Beware of Automatic Type Conversions</h2>

<p>JavaScript is loosely typed.<br><br>

A variable can contain all data types.<br><br>

A variable can change its data type:</p>

<h3>Example:</h3>
<pre>
let x = "Hello";     
// typeof x is a string
x = 5;             
// changes typeof x to a number
</pre>

<p>Beware that numbers can accidentally be converted to strings or NaN (Not a Number).<br><br>

When doing mathematical operations, JavaScript can convert numbers to strings:</p>

<h3>Example:</h3>
<pre>
let x = 5 + 7;       
// x.valueOf() is 12, 
typeof x is a number
let x = 5 + "7";     
// x.valueOf() is 57,  
typeof x is a string
let x = "5" + 7;     
// x.valueOf() is 57,  
typeof x is a string
let x = 5 - 7;      
// x.valueOf() is -2, 
typeof x is a number
let x = 5 - "7";     
// x.valueOf() is -2,  
typeof x is a number
let x = "5" - 7;     
// x.valueOf() is -2, 
typeof x is a number
let x = 5 - "x";    
// x.valueOf() is NaN, 
typeof x is a number
</pre>

<p>Subtracting a string from a string, does not generate an error but returns NaN (Not a Number):</p>

<h3>Example:</h3>
<pre>
  "Hello" - "Dolly"    
// returns NaN
</pre>

<h2>Use === Comparison</h2>
<p>
  The == comparison operator always converts (to matching types) before comparison.<br><br>

The === operator forces comparison of values and type:</p>

<h3>Example</h3>
<pre>
0 == "";      
// true
1 == "1";     
// true
1 == true;   
// true

0 === "";     
// false
1 === "1";     
// false
1 === true;   
// false
</pre>

<h2>Use Parameter Defaults</h2>
<p>
If a function is called with a missing argument, the value of the missing argument is set to undefined.<br><br>

Undefined values can break your code. It is a good habit to assign default values to arguments.
</p>

<h3>Example</h3>
<pre>
function myFunction(x, y) {
  if (y === undefined) {
    y = 0;
  }
}
</pre>

<h3>Output:</h3>
<div>
<p>Remove the comment (at the beginning of each line) to test each case:</p>

<p id="demo1"></p>

<script>
let x;
//x = (0 == "");   // true
//x = (1 == "1");  // true
//x = (1 == true);   // true
//x = (0 === "");  // false
//x = (1 === "1");   // false
//x = (1 === true);  // false
document.getElementById("demo1").innerHTML = x;
</script>
</div>

<p>ECMAScript 2015 allows default parameters in the function definition:</p>

<h2>End Your Switches with Defaults</h2>
<p>Always end your switch statements with a default. Even if you think there is no need for it.</p>

<h3>Exampke:</h3>
<pre>
switch (new Date().getDay()) {
  case 0:
    day = "Sunday";
    break;
  case 1:
    day = "Monday";
    break;
  case 2:
    day = "Tuesday";
    break;
  case 3:
    day = "Wednesday";
    break;
  case 4:
    day = "Thursday";
    break;
  case 5:
    day = "Friday";
    break;
  case 6:
    day = "Saturday";
    break;
  default:
    day = "Unknown";
}
</pre>

<h3>Output:</h3>
<div>
<p id="demo2"></p>
<script>
let day;
switch (new Date().getDay()) {
  case 0:
    day = "Sunday";
    break;
  case 1:
day = "Monday";
    break;
  case 2:
    day = "Tuesday";
    break;
  case 3:
    day = "Wednesday";
    break;
case 4:
    day = "Thursday";
    break;
  case 5:
    day = "Friday";
    break;
  case  6:
    day = "Saturday";
break;
  default:
     day = "unknown";
}
document.getElementById("demo2").innerHTML = "Today is " + day;
</script>
</div>

<h2>Avoid Number, String, and Boolean as Objects</h2>
<p>Always treat numbers, strings, or booleans as primitive values. Not as objects.<br><br>

Declaring these types as objects, slows down execution speed, and produces nasty side effects:</p>

<h3>Example:</h3>
<pre>
let x = "John";             
let y = new String("John");
(x === y) 
// is false because x is a string and y is an object.
</pre>

<p>Or even worse:</p>
<h3>Exampke:</h3>
<pre>
let x = new String("John");             
let y = new String("John");
(x == y) 
// is false because you cannot compare objects.
</pre>

<h2>Avoid Using eval()</h2>
<p>
The eval() function is used to run text as code. In almost all cases, it should not be necessary to use it.<br><br>

Because it allows arbitrary code to be run, it also represents a security problem.
</p>


</body>
</html>