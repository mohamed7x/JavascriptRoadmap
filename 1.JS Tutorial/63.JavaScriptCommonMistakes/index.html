<!!DOCTYPE html>
<html>
<body>

<h1>JavaScript Common Mistakes</h1>
<p>This chapter points out some common JavaScript mistakes.</p>
<h2>Accidentally Using the Assignment Operator</h2>
<p>JavaScript programs may generate unexpected results if a programmer accidentally uses an assignment operator (=), instead of a comparison operator (==) in an if statement.<br><br>

This if statement returns false (as expected) because x is not equal to 10:</p>
<h3>Example</h3>
<pre>
let x = 0;
if (x == 10)
</pre>
<h3>Output</h3>
<div>
  <p>This returns false (as expected) because x is not equal to 10:</p>

<p id="demo"></p>

<script>
let x = 0;
document.getElementById("demo").innerHTML = Boolean(x == 10);
</script>
</div>
<p>This if statement returns true (maybe not as expected), because 10 is true:</p>
<h3>Example</h3>
<pre>
let x = 0;
if (x = 10)
</pre>

<h3>Output:</h3>
<div>
<p>This returns true (maybe not as expected), because 10 is true:</p>

<p id="demo1"></p>

<script>
let x1 = 0;
document.getElementById("demo1").innerHTML = Boolean(x1 = 10);
</script>
</div>

<p>This if statement returns false (maybe not as expected), because 0 is false:
</p>
<h3>Example</h3>
<pre>
let x = 0;
if (x = 0)
</pre>
<h3>Output</h3>
<div>
<p>This if statement returns false (maybe not as expected), because 0 is false:</p>

<p id="demo2"></p>

<script>
let x2 = 0;
document.getElementById("demo2").innerHTML = Boolean(x2 = 0);
</script>

<p style="background-color:yellow;">An assignment always returns the value of the assignment.</p>

<h2>Expecting Loose Comparison</h2>
<p>In regular comparison, data type does not matter. This if statement returns true:</p>
<pre>
let x = 10;
let y = "10";
if (x == y)
</pre>
<h3>Output</h3>
<div>
<p>In regular comparison, data type does not matter. This if statement returns true:</p>

<p id="demo3"></p>

<script>
let x3 = 10;
let y = "10";
document.getElementById("demo3").innerHTML = Boolean(x3 == y);
</script>
</div>


<p>In strict comparison, data type does matter. This if statement returns false:</p>

<pre>
let x = 10;
let y = "10";
if (x === y)
</pre>
<h3>Output</h3>
<div>
<p>In strict comparison, data type does matter. This if statement returns false:</p>
<p id="demo4"></p>
<script>
let x4 = 10;
let y4 = "10";
document.getElementById("demo4").innerHTML = Boolean(x4 === y4);
</script>
</div>


<p>It is a common mistake to forget that switch statements use strict comparison:
<br><br>
This case switch will display an alert:</p>

<pre>
let x = 10;
switch(x) {
  case 10: alert("Hello");
}
</pre>
<div>
<p>It is a common mistake to forget that switch statements use strict comparison.</p>
<p>This will work:</p>

<p id="demo5"></p>

<script>
let x5 = 10;
switch(x5) {
  case 10: document.getElementById("demo5").innerHTML = "Hello";
}
</script>
</div>

<p>This case switch will not display an alert:</p>

<pre>
let x = 10;
switch(x) {
  case "10": alert("Hello");
}
</pre>

<h3>Output</h3>
<div>
<p>It is a common mistake to forget that switch statements use strict comparison.</p>
<p>This will not work:</p>

<p id="demo6"></p>
<script>
let x6 = 10;
switch(x6) {
  case "10": document.getElementById("demo6").innerHTML = "Hello";
}
</script>
</div>

<h2>Confusing Addition & Concatenation</h2>
<p>Addition is about adding numbers.<br><br>

Concatenation is about adding strings.<br><br>

In JavaScript both operations use the same + operator.<br><br>

Because of this, adding a number as a number will produce a different result from adding a number as a string:</p>

<pre>
let x = 10;
x = 10 + 5;       
// Now x is 15

let y = 10;
y += "5";      
// Now y is "105"
</pre>

<p>When adding two variables, it can be difficult to anticipate the result:</p>

<pre>
let x = 10;
let y = 5;
let z = x + y;    
// Now z is 15

let x = 10;
let y = "5";
let z = x + y;     
// Now z is "105"
</pre>

<h2>Misunderstanding Floats</h2>
<p>
All numbers in JavaScript are stored as 64-bits Floating point numbers (Floats).
<br><br>
All programming languages, including JavaScript, have difficulties with precise floating point values:
</p>

<pre>
let x = 0.1;
let y = 0.2;
let z = x + y           
// the result in z will not be 0.3
</pre>

<h3>Output</h3>
<div>
<p id="demo7"></p>
<script>
let x7 = 0.1;
let y7 = 0.2;
let z = x7 + y7;
document.getElementById("demo7").innerHTML = z;
</script>
</div>
<p>To solve the problem above, it helps to multiply and divide:</p>
<pre>
let z = (x * 10 + y * 10) / 10;    
// z will be 0.3
</pre>

<h2>Breaking a JavaScript String</h2>
<p>JavaScript will allow you to break a statement into two lines:</p>

<h3>Example 1</h3>
<pre>
let x =
"Hello World!";
</pre>

<p>But, breaking a statement in the middle of a string will not work:</p>

<h3>Example 2</h3>
<pre>
let x = "Hello
World!";
</pre>
<p>You must use a "backslash" if you must break a statement in a string:</p>

<h3>Example 3</h3>
<pre>
let x = "Hello \
World!";
</pre>

<h2>Misplacing Semicolon</h2>
<p>Because of a misplaced semicolon, this code block will execute regardless of the value of x:</p>
<pre>
if (x == 19);
{
  // code block 
}
</pre>

<h2>Breaking a Return Statement</h2>
<p>It is a default JavaScript behavior to close a statement automatically at the end of a line.<br><br>

Because of this, these two examples will return the same result:</p>

<h3>Exampke 1</h3>
<pre>
function myFunction(a) {
  let power = 10 
  return a * power
}
</pre>
<<h3>Example 2</h3>
<pre>
function myFunction(a) {
  let power = 10;
  return a * power;
}
</pre>

<p>JavaScript will also allow you to break a statement into two lines.<br><br>

Because of this, example 3 will also return the same result:</p>

<h3>Example 3</h3>
<pre>
function myFunction(a) {
  let
  power = 10; 
  return a * power;
}
</pre>
<p>But, what will happen if you break the return statement in two lines like this:</p>
<h3>Example 4</h3>
<pre>
function myFunction(a) {
  let
  power = 10; 
  return
  a * power;
}

</pre>
<p>The function will return undefined!
<br>
Why? Because JavaScript thought you meant:</p>

<pre>
function myFunction(a) {
  let
  power = 10; 
  return;
  a * power;
}
</pre>

<h3>Explanation</h3>
<p>If a statement is incomplete like:</p>

<code>
let
</code>
<p>JavaScript will try to complete the statement by reading the next line:</p>

<code>
power = 10;
</code>
<p>But since this statement is complete:</p>
<code>return</code>
<p>JavaScript will automatically close it like this:</p>
<code>return;</code>

<p>This happens because closing (ending) statements with semicolon is optional in JavaScript.<br><br>

JavaScript will close the return statement at the end of the line, because it is a complete statement.</p>
<p style="background-color:red;">Never break a return statement.</p>

<h2>Accessing Arrays with Named Indexes</h2>
<p>Many programming languages support arrays with named indexes.<br><br>

Arrays with named indexes are called associative arrays (or hashes).<br><br>

JavaScript does not support arrays with named indexes.<br><br>

In JavaScript, arrays use numbered indexes:  </p>

<h3>Example</h3>
<pre>
const person = [];
person[0] = "John";
person[1] = "Doe";
person[2] = 46;
person.length;      
// person.length will return 3
person[0];           
// person[0] will return "John"
</pre>
<p>In JavaScript, objects use named indexes.<br><br>

If you use a named index, when accessing an array, JavaScript will redefine the array to a standard object.<br><br>

After the automatic redefinition, array methods and properties will produce undefined or incorrect results:</p>

<h3>Example</h3>
<pre>
const person = [];
person["firstName"] = "John";
person["lastName"] = "Doe";
person["age"] = 46;
person.length;     
// person.length will return 0
person[0];          
// person[0] will return undefined
</pre>

<h2>Ending Definitions with a Comma</h2>
<p>Trailing commas in object and array definition are legal in ECMAScript 5.</p>

<h3>Object Example:</h3>
<pre>
person = {firstName:"John", lastName:"Doe", age:46,}
</pre>
<h3>Array Example:</h3>
<pre>
points = [40, 100, 1, 5, 25, 10,];
</pre>

<h3>JSON:</h3>
<pre>
person = {"firstName":"John", "lastName":"Doe", "age":46}
</pre>

<h3>JSON:</h3>
<pre>
points = [40, 100, 1, 5, 25, 10];
</pre>

<h2>Undefined is Not Null</h2>
<p>JavaScript objects, variables, properties, and methods can be undefined.
<br><br>
In addition, empty JavaScript objects can have the value null.<br><br>

This can make it a little bit difficult to test if an object is empty.<br><br>

You can test if an object exists by testing if the type is undefined:</p>

<h3>Example</h3>
<pre>
if (typeof myObj === "undefined") 
</pre>

<h3>Output:</h3>
<div>
<p>To test if an object does not exist, test if the type is undefined:</p>
<p id="demo8"></p>
<script>
document.getElementById("demo8").innerHTML = typeof myObj === "undefined";
</script>
</div>
<p>But you cannot test if an object is null, because this will throw an error if the object is undefined:</p>

<h3>Incorrect:</h3>
<pre>
if (myObj === null) 
</pre>

<p>To solve this problem, you must test if an object is not null, and not undefined.
<br><br>
But this can still throw an error:</p>

<h3>Correct:</h3>
<pre>
if (typeof myObj !== "undefined" && myObj !== null) 
</pre>
<h3>Output:</h3>
<div>
<p>If you want to test if an object is not null, you must test if it not undefined first.</p>
<p id="demo9"></p>
<script>
document.getElementById("demo9").innerHTML = typeof myObj !== "undefined" && myObj !== null;
</script>
</div>

</body>
</html>